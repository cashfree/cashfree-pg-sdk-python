# coding: utf-8

"""
    Cashfree Payment Gateway APIs

    Cashfree's Payment Gateway APIs provide developers with a streamlined pathway to integrate advanced payment processing capabilities into their applications, platforms and websites.

    The version of the OpenAPI document: 2023-08-01
    Contact: developers@cashfree.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist
from cashfree_pg.models.eligibility_method_item_entity_details_available_handles_inner import EligibilityMethodItemEntityDetailsAvailableHandlesInner
from cashfree_pg.models.subscription_bank_details import SubscriptionBankDetails

class EligibilityMethodItemEntityDetails(BaseModel):
    """
    EligibilityMethodItemEntityDetails
    """
    account_types: Optional[conlist(StrictStr)] = Field(None, description="List of account types associated with the payment method. (e.g. SAVINGS or CURRENT)")
    frequent_bank_details: Optional[conlist(SubscriptionBankDetails)] = Field(None, description="List of the most frequently used banks.")
    all_bank_details: Optional[conlist(SubscriptionBankDetails)] = Field(None, description="Details about all banks associated with the payment method.")
    available_handles: Optional[conlist(EligibilityMethodItemEntityDetailsAvailableHandlesInner)] = Field(None, description="List of supported VPA handles.")
    allowed_card_types: Optional[conlist(StrictStr)] = Field(None, description="List of allowed card types. (e.g. DEBIT_CARD, CREDIT_CARD)")
    __properties = ["account_types", "frequent_bank_details", "all_bank_details", "available_handles", "allowed_card_types"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> EligibilityMethodItemEntityDetails:
        """Create an instance of EligibilityMethodItemEntityDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))
    
    @classmethod
    def from_json_for_one_of(cls, json_str: str) -> EligibilityMethodItemEntityDetails:
        """Create an instance of EligibilityMethodItemEntityDetails from a JSON string"""
        temp_dict = json.loads(json_str)
        if "account_types, frequent_bank_details, all_bank_details, available_handles, allowed_card_types" in temp_dict.keys():
            return cls.from_dict(json.loads(json_str))
        return None

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in frequent_bank_details (list)
        _items = []
        if self.frequent_bank_details:
            for _item in self.frequent_bank_details:
                if _item:
                    _items.append(_item.to_dict())
            _dict['frequent_bank_details'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in all_bank_details (list)
        _items = []
        if self.all_bank_details:
            for _item in self.all_bank_details:
                if _item:
                    _items.append(_item.to_dict())
            _dict['all_bank_details'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in available_handles (list)
        _items = []
        if self.available_handles:
            for _item in self.available_handles:
                if _item:
                    _items.append(_item.to_dict())
            _dict['available_handles'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> EligibilityMethodItemEntityDetails:
        """Create an instance of EligibilityMethodItemEntityDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return EligibilityMethodItemEntityDetails.parse_obj(obj)

        _obj = EligibilityMethodItemEntityDetails.parse_obj({
            "account_types": obj.get("account_types"),
            "frequent_bank_details": [SubscriptionBankDetails.from_dict(_item) for _item in obj.get("frequent_bank_details")] if obj.get("frequent_bank_details") is not None else None,
            "all_bank_details": [SubscriptionBankDetails.from_dict(_item) for _item in obj.get("all_bank_details")] if obj.get("all_bank_details") is not None else None,
            "available_handles": [EligibilityMethodItemEntityDetailsAvailableHandlesInner.from_dict(_item) for _item in obj.get("available_handles")] if obj.get("available_handles") is not None else None,
            "allowed_card_types": obj.get("allowed_card_types")
        })
        return _obj


